<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>src\js\common\apiPromiseMixin.js - ozpIwc</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="icon" href="../assets/favicon.ico">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title="ozpIwc" width="117" height="52"></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: launch-in-webtop</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/ozpIwc.alert.html">ozpIwc.alert</a></li>
                                <li><a href="../classes/ozpIwc.api.html">ozpIwc.api</a></li>
                                <li><a href="../classes/ozpIwc.api.base.Api.html">ozpIwc.api.base.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.base.Node.html">ozpIwc.api.base.Node</a></li>
                                <li><a href="../classes/ozpIwc.api.data.Api.html">ozpIwc.api.data.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.data.node.Node.html">ozpIwc.api.data.node.Node</a></li>
                                <li><a href="../classes/ozpIwc.api.data.node.Nodev2.html">ozpIwc.api.data.node.Nodev2</a></li>
                                <li><a href="../classes/ozpIwc.api.Endpoint.html">ozpIwc.api.Endpoint</a></li>
                                <li><a href="../classes/ozpIwc.api.EndpointRegistry.html">ozpIwc.api.EndpointRegistry</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadActionError.html">ozpIwc.api.error.BadActionError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadContentError.html">ozpIwc.api.error.BadContentError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadRequestError.html">ozpIwc.api.error.BadRequestError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadResourceError.html">ozpIwc.api.error.BadResourceError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BadStateError.html">ozpIwc.api.error.BadStateError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.BaseError.html">ozpIwc.api.error.BaseError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.NoActionError.html">ozpIwc.api.error.NoActionError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.NoMatchError.html">ozpIwc.api.error.NoMatchError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.NoPermissionError.html">ozpIwc.api.error.NoPermissionError</a></li>
                                <li><a href="../classes/ozpIwc.api.error.NoResourceError.html">ozpIwc.api.error.NoResourceError</a></li>
                                <li><a href="../classes/ozpIwc.api.filter.base.html">ozpIwc.api.filter.base</a></li>
                                <li><a href="../classes/ozpIwc.api.filter.Function.html">ozpIwc.api.filter.Function</a></li>
                                <li><a href="../classes/ozpIwc.api.filter.standard.html">ozpIwc.api.filter.standard</a></li>
                                <li><a href="../classes/ozpIwc.api.intents.Api.html">ozpIwc.api.intents.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.intents.FSM.html">ozpIwc.api.intents.FSM</a></li>
                                <li><a href="../classes/ozpIwc.api.Lifespan.Bound.html">ozpIwc.api.Lifespan.Bound</a></li>
                                <li><a href="../classes/ozpIwc.api.Lifespan.Ephemeral.html">ozpIwc.api.Lifespan.Ephemeral</a></li>
                                <li><a href="../classes/ozpIwc.api.Lifespan.Persistent.html">ozpIwc.api.Lifespan.Persistent</a></li>
                                <li><a href="../classes/ozpIwc.api.locks.Api.html">ozpIwc.api.locks.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.locks.Node.html">ozpIwc.api.locks.Node</a></li>
                                <li><a href="../classes/ozpIwc.api.names.Api.html">ozpIwc.api.names.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.names.Node.html">ozpIwc.api.names.Node</a></li>
                                <li><a href="../classes/ozpIwc.api.system.Api.html">ozpIwc.api.system.Api</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.ApplicationNode.html">ozpIwc.api.system.node.ApplicationNode</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.ApplicationNodeV2.html">ozpIwc.api.system.node.ApplicationNodeV2</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.SystemNode.html">ozpIwc.api.system.node.SystemNode</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.UserNode.html">ozpIwc.api.system.node.UserNode</a></li>
                                <li><a href="../classes/ozpIwc.api.system.node.UserNodeV2.html">ozpIwc.api.system.node.UserNodeV2</a></li>
                                <li><a href="../classes/ozpIwc.apiMap.html">ozpIwc.apiMap</a></li>
                                <li><a href="../classes/ozpIwc.Client.html">ozpIwc.Client</a></li>
                                <li><a href="../classes/ozpIwc.Debugger.html">ozpIwc.Debugger</a></li>
                                <li><a href="../classes/ozpIwc.Lifespan.html">ozpIwc.Lifespan</a></li>
                                <li><a href="../classes/ozpIwc.log.html">ozpIwc.log</a></li>
                                <li><a href="../classes/ozpIwc.metric.Registry.html">ozpIwc.metric.Registry</a></li>
                                <li><a href="../classes/ozpIwc.metric.stats.BinaryHeap.html">ozpIwc.metric.stats.BinaryHeap</a></li>
                                <li><a href="../classes/ozpIwc.metric.stats.ExponentiallyDecayingSample.html">ozpIwc.metric.stats.ExponentiallyDecayingSample</a></li>
                                <li><a href="../classes/ozpIwc.metric.stats.Sample.html">ozpIwc.metric.stats.Sample</a></li>
                                <li><a href="../classes/ozpIwc.metric.stats.UniformSample.html">ozpIwc.metric.stats.UniformSample</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.BaseMetric.html">ozpIwc.metric.types.BaseMetric</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.Counter.html">ozpIwc.metric.types.Counter</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.Gauge.html">ozpIwc.metric.types.Gauge</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.Histogram.html">ozpIwc.metric.types.Histogram</a></li>
                                <li><a href="../classes/ozpIwc.metric.types.Meter.html">ozpIwc.metric.types.Meter</a></li>
                                <li><a href="../classes/ozpIwc.network.KeyBroadcastLocalStorageLink.html">ozpIwc.network.KeyBroadcastLocalStorageLink</a></li>
                                <li><a href="../classes/ozpIwc.network.Peer.html">ozpIwc.network.Peer</a></li>
                                <li><a href="../classes/ozpIwc.packet.Fragment.html">ozpIwc.packet.Fragment</a></li>
                                <li><a href="../classes/ozpIwc.packet.FragmentStore.html">ozpIwc.packet.FragmentStore</a></li>
                                <li><a href="../classes/ozpIwc.packet.Network.html">ozpIwc.packet.Network</a></li>
                                <li><a href="../classes/ozpIwc.packet.Transport.html">ozpIwc.packet.Transport</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.elements.SecurityAttribute.html">ozpIwc.policyAuth.elements.SecurityAttribute</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.points.PDP.html">ozpIwc.policyAuth.points.PDP</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.points.PIP.html">ozpIwc.policyAuth.points.PIP</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.points.PRP.html">ozpIwc.policyAuth.points.PRP</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.points.utils.html">ozpIwc.policyAuth.points.utils</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.policies.html">ozpIwc.policyAuth.policies</a></li>
                                <li><a href="../classes/ozpIwc.policyAuth.PolicyCombining.html">ozpIwc.policyAuth.PolicyCombining</a></li>
                                <li><a href="../classes/ozpIwc.Timer.html">ozpIwc.Timer</a></li>
                                <li><a href="../classes/ozpIwc.transport.consensus.Base.html">ozpIwc.transport.consensus.Base</a></li>
                                <li><a href="../classes/ozpIwc.transport.consensus.Bully.html">ozpIwc.transport.consensus.Bully</a></li>
                                <li><a href="../classes/ozpIwc.transport.listener.SharedWorker.html">ozpIwc.transport.listener.SharedWorker</a></li>
                                <li><a href="../classes/ozpIwc.transport.PacketContext.html">ozpIwc.transport.PacketContext</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Base.html">ozpIwc.transport.participant.Base</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Client.html">ozpIwc.transport.participant.Client</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Debugger.html">ozpIwc.transport.participant.Debugger</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Internal.html">ozpIwc.transport.participant.Internal</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.Multicast.html">ozpIwc.transport.participant.Multicast</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.MutexClient.html">ozpIwc.transport.participant.MutexClient</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.PostMessage.html">ozpIwc.transport.participant.PostMessage</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.RouterWatchdog.html">ozpIwc.transport.participant.RouterWatchdog</a></li>
                                <li><a href="../classes/ozpIwc.transport.participant.SharedWorker.html">ozpIwc.transport.participant.SharedWorker</a></li>
                                <li><a href="../classes/ozpIwc.transport.Router.html">ozpIwc.transport.Router</a></li>
                                <li><a href="../classes/ozpIwc.util.html">ozpIwc.util</a></li>
                                <li><a href="../classes/ozpIwc.util.AjaxPersistenceQueue.html">ozpIwc.util.AjaxPersistenceQueue</a></li>
                                <li><a href="../classes/ozpIwc.util.ApiPromiseMixin.html">ozpIwc.util.ApiPromiseMixin</a></li>
                                <li><a href="../classes/ozpIwc.util.AsyncAction.html">ozpIwc.util.AsyncAction</a></li>
                                <li><a href="../classes/ozpIwc.util.CancelableEvent.html">ozpIwc.util.CancelableEvent</a></li>
                                <li><a href="../classes/ozpIwc.util.Event.html">ozpIwc.util.Event</a></li>
                                <li><a href="../classes/ozpIwc.util.mutex.html">ozpIwc.util.mutex</a></li>
                                <li><a href="../classes/ozpIwc.util.object.html">ozpIwc.util.object</a></li>
                                <li><a href="../classes/ozpIwc.util.PacketRouter.html">ozpIwc.util.PacketRouter</a></li>
                                <li><a href="../classes/ozpIwc.util.Reference.html">ozpIwc.util.Reference</a></li>
                                <li><a href="../classes/ozpIwc.wiring.html">ozpIwc.wiring</a></li>
                            </ul>
                
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/ozpIwc.html">ozpIwc</a></li>
                                <li><a href="../modules/ozpIwc.api.html">ozpIwc.api</a></li>
                                <li><a href="../modules/ozpIwc.api.base.html">ozpIwc.api.base</a></li>
                                <li><a href="../modules/ozpIwc.api.data.html">ozpIwc.api.data</a></li>
                                <li><a href="../modules/ozpIwc.api.data.node.html">ozpIwc.api.data.node</a></li>
                                <li><a href="../modules/ozpIwc.api.error.html">ozpIwc.api.error</a></li>
                                <li><a href="../modules/ozpIwc.api.filter.html">ozpIwc.api.filter</a></li>
                                <li><a href="../modules/ozpIwc.api.intents.html">ozpIwc.api.intents</a></li>
                                <li><a href="../modules/ozpIwc.api.intents.node.html">ozpIwc.api.intents.node</a></li>
                                <li><a href="../modules/ozpIwc.api.locks.html">ozpIwc.api.locks</a></li>
                                <li><a href="../modules/ozpIwc.api.names.html">ozpIwc.api.names</a></li>
                                <li><a href="../modules/ozpIwc.api.system.html">ozpIwc.api.system</a></li>
                                <li><a href="../modules/ozpIwc.api.system.node.html">ozpIwc.api.system.node</a></li>
                                <li><a href="../modules/ozpIwc.metric.html">ozpIwc.metric</a></li>
                                <li><a href="../modules/ozpIwc.metric.stats.html">ozpIwc.metric.stats</a></li>
                                <li><a href="../modules/ozpIwc.metric.types.html">ozpIwc.metric.types</a></li>
                                <li><a href="../modules/ozpIwc.network.html">ozpIwc.network</a></li>
                                <li><a href="../modules/ozpIwc.packet.html">ozpIwc.packet</a></li>
                                <li><a href="../modules/ozpIwc.policyAuth.html">ozpIwc.policyAuth</a></li>
                                <li><a href="../modules/ozpIwc.policyAuth.elements.html">ozpIwc.policyAuth.elements</a></li>
                                <li><a href="../modules/ozpIwc.policyAuth.points.html">ozpIwc.policyAuth.points</a></li>
                                <li><a href="../modules/ozpIwc.transport.html">ozpIwc.transport</a></li>
                                <li><a href="../modules/ozpIwc.transport.consensus.html">ozpIwc.transport.consensus</a></li>
                                <li><a href="../modules/ozpIwc.transport.listener.html">ozpIwc.transport.listener</a></li>
                                <li><a href="../modules/ozpIwc.transport.participant.html">ozpIwc.transport.participant</a></li>
                                <li><a href="../modules/ozpIwc.util.html">ozpIwc.util</a></li>
                                <li><a href="../modules/ozpIwc.worker.html">ozpIwc.worker</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<h1 class="file-heading">File: src\js\common\apiPromiseMixin.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
var ozpIwc = ozpIwc || {};
ozpIwc.util = ozpIwc.util || {};

/**
 * @module ozpIwc
 * @submodule ozpIwc.util
 */

ozpIwc.util.ApiPromiseMixin = (function (apiMap, log, util) {
    /**
     * @class ApiPromiseMixin
     * @namespace ozpIwc.util
     * @static
     * Augments a participant or connection that supports basic IWC communications
     * functions for sending and receiving.
     * @uses ozpIwc.util.Event
     * @param {ozpIwc.transport.participant.Base} participant
     * @param {Boolean} autoConnect
     */
    var ApiPromiseMixin = function (participant, autoConnect) {
        autoConnect = (typeof autoConnect === &quot;undefined&quot; || autoConnect);

        participant.address = participant.address || &quot;$nobody&quot;;
        participant.connect = participant.connect || function () {
                participant.connectPromise = Promise.resolve();
                return participant.connectPromise;
            };

        if (!participant.events) {
            participant.events = new util.Event();
            participant.events.mixinOnOff(participant);
        }

        var mixins = ApiPromiseMixin.getCore();
        for (var i in mixins) {
            participant[i] = mixins[i];
        }

        participant.readLaunchParams(util.globalScope.name);
        participant.readLaunchParams(util.globalScope.location.search);
        participant.readLaunchParams(util.globalScope.location.hash);

        ApiPromiseMixin.registerEvents(participant);

        participant.constructApiFunctions();

        if (autoConnect) {
            participant.connect().catch(function(err) {
                // Supress the error here, the application will get it from its
                // connect() call.
            });
        }
    };

    /**
     * Registers event listeners for the participant.  Listens for the following events: disconnect.
     * @method registerEvents
     * @static
     * @param {ozpIwc.transport.participant.Base} participant
     */
    ApiPromiseMixin.registerEvents = function (participant) {
        participant.on(&quot;disconnect&quot;, function () {
            participant.promiseCallbacks = {};
            participant.registeredCallbacks = {};
            util.globalScope.removeEventListener(&quot;message&quot;, participant.postMessageHandler, false);
            participant.connectPromise = null;
        });
    };

    /**
     * A factory for the apiPromise functionality.
     *
     * @method getCore
     * @static
     * @return {Object}
     */
    ApiPromiseMixin.getCore = function () {
        return {

            /**
             * @property promiseCallbacks
             * @type Object
             * @default {}
             */
            promiseCallbacks: {},

            /**
             * @property msgIdSequence
             * @type Number
             * @default 0
             */
            msgIdSequence: 0,

            /**
             * @property receivedPackets
             * @type Number
             * @default 0
             */
            receivedPackets: 0,

            /**
             * @property receivedBytes
             * @type Number
             * @default 0
             */
            receivedBytes: 0,

            /**
             * @property sentPackets
             * @type Number
             * @default 0
             */
            sentPackets: 0,

            /**
             * @property sentBytes
             * @type Number
             * @default 0
             */
            sentBytes: 0,

            /**
             * The epoch time the Client was instantiated.
             * @property startTime
             * @type Number
             */
            startTime: util.now(),

            /**
             * A map of available apis and their actions.
             * @property apiMap
             * @type Object
             */
            apiMap: apiMap || {},

            /**
             * @property wrapperMap
             * @type Object
             * @default {}
             */
            wrapperMap: {},

            /**
             * @property preconnectionQueue
             * @type Array
             * @default []
             */
            preconnectionQueue: [],

            /**
             * @property launchParams
             * @type Object
             * @default {}
             */
            launchParams: {},

            /**
             * @property watchMsgMap
             * @type Object
             * @default {}
             */
            watchMsgMap: {},

            /**
             * @property registeredCallbacks
             * @type Object
             * @default {}
             */
            registeredCallbacks: {},

            /**
             * @property launchedIntents
             * @type Array
             * @default []
             */
            launchedIntents: [],

            /**
             * Returns whether or not the participant is connected to the IWC bus.
             *
             * @method isConnected
             * @return {Boolean}
             */
            isConnected: function () {
                return this.address !== &quot;$nobody&quot;;
            },

            /**
             * Parses launch parameters based on the raw string input it receives.
             *
             * @method readLaunchParams
             * @param {String} rawString
             */
            readLaunchParams: function (rawString) {
                // of the form ozpIwc.VARIABLE=VALUE, where:
                //   VARIABLE is alphanumeric + &quot;_&quot;
                //   VALUE does not contain &amp; or #
                var re = /ozpIwc.(\w+)=([^&amp;#]+)/g;
                var m;
                while ((m = re.exec(rawString)) !== null) {
                    var params = decodeURIComponent(m[2]);
                    try {
                        params = JSON.parse(params);
                    } catch (e) {
                        // ignore the errors and just pass through the string
                    }
                    this.launchParams[m[1]] = params;
                }
            },

            /**
             * Receive a packet from the connected peer.  If the packet is a reply, then
             * the callback for that reply is invoked.  Otherwise, it fires a receive event
             *
             * Fires:
             *     - {{#crossLink &quot;ozpIwc.Client/receive:event}}{{/crossLink}}
             *
             * @method receive
             * @protected
             * @param {ozpIwc.packet.Transport} packetContext
             */
            receiveFromRouterImpl: function (packetContext) {
                var handled = false;

                // If no packet, it is likely a $transport packet.
                var packet = packetContext.packet || packetContext;
                //Try and handle this packet as a reply message
                if (packet.replyTo &amp;&amp; this.promiseCallbacks[packet.replyTo]) {

                    var replyCancel = false;
                    var replyDone = function () {
                        replyCancel = true;
                    };
                    this.promiseCallbacks[packet.replyTo](packet, replyDone);

                    if (replyCancel) {
                        this.cancelPromiseCallback(packet.replyTo);
                        handled = true;
                    }

                }

                //Try and handle this packet as callback message
                if (!handled &amp;&amp; packet.replyTo &amp;&amp; this.registeredCallbacks[packet.replyTo]) {

                    var registeredCancel = false;
                    var self = this;
                    var registeredDone = function () {
                        registeredCancel = true;

                        if (self.watchMsgMap[packet.replyTo] &amp;&amp; self.watchMsgMap[packet.replyTo].action === &quot;watch&quot;) {
                            self.api(self.watchMsgMap[packet.replyTo].dst).unwatch(self.watchMsgMap[packet.replyTo].resource);
                        }
                        self.cancelRegisteredCallback(packet.replyTo);
                    };

                    handled = this.registeredCallbacks[packet.replyTo](packet, registeredDone);
                }
                if (!handled) {
                    //Drop own packets
                    if (packet.src === this.address) {
                        return;
                    }

                    if (packet.dst === &quot;$bus.multicast&quot;) {
                        //If not handle-able by the mixin, trigger &quot;busPacket&quot; for someone to handle
                        if (!handleBusPacket(this, packet)) {
                            this.events.trigger(&quot;busPacket&quot;, packetContext);
                        }
                    } else {
                        //Not bus packet, trigger &quot;receive&quot; for someone to handle
                        this.events.trigger(&quot;receive&quot;, packetContext);
                    }
                }
            },

            /**
             * Builds the client api calls from the values in client.apiMap
             *
             * @method constructApiFunctions
             */
            constructApiFunctions: function () {
                for (var api in this.apiMap) {
                    var apiObj = this.apiMap[api];
                    var apiFuncName = apiObj.address.replace(&#x27;.api&#x27;, &#x27;&#x27;);

                    //prevent overriding client constructed fields, but allow updating of constructed APIs
                    if (!this.hasOwnProperty(apiFuncName) || this.apiMap[api].functionName === apiFuncName) {
                        // wrap this in a function to break the closure
                        // on apiObj.address that would otherwise register
                        // everything for the last api in the list
                        /*jshint loopfunc:true*/
                        (function (self, addr) {
                            self[apiFuncName] =  self.updateApi(addr);
                            self.apiMap[addr] = self.apiMap[addr] || {};
                            self.apiMap[addr].functionName = apiFuncName;
                        })(this, apiObj.address);
                    }
                }
            },

            /**
             * Calls the names.api to gather the /api/* resources to gain knowledge of available api actions of the
             * current bus.
             *
             * @method gatherApiInformation
             * @return {Promise}
             */
            gatherApiInformation: function () {
                var self = this;
                // gather api information
                return this.send({
                    dst: &quot;names.api&quot;,
                    action: &quot;get&quot;,
                    resource: &quot;/api&quot;
                }).then(function (reply) {
                    if (reply.response === &#x27;ok&#x27;) {
                        return reply.entity;
                    } else {
                        throw reply.response;
                    }
                }).then(function (apis) {
                    var promiseArray = [];
                    apis.forEach(function (api) {
                        var promise = self.send({
                            dst: &quot;names.api&quot;,
                            action: &quot;get&quot;,
                            resource: api
                        }).then(function (res) {
                            if (res.response === &#x27;ok&#x27;) {
                                var name = api.replace(&#x27;/api/&#x27;, &#x27;&#x27;);
                                self.apiMap[name] = self.apiMap[name] || {};
                                self.apiMap[name].address = name;
                                self.apiMap[name].actions = res.entity.actions;
                            } else {
                                throw res.response;
                            }
                        });
                        promiseArray.push(promise);
                    });
                    return Promise.all(promiseArray);
                });
            },

            /**
             * Cancel a reply callback registration.
             * @method cancelPromiseCallback
             * @param (String} msgId The packet replyTo ID for which the callback was registered.
             *
             * @return {Boolean} True if the cancel was successful, otherwise false.
             */
            cancelPromiseCallback: function (msgId) {
                var success = false;
                if (msgId) {
                    delete this.promiseCallbacks[msgId];
                    success = true;
                }
                return success;
            },

            /**
             * Cancel a watch callback registration.
             *
             * @method cancelRegisteredCallback
             * @param (String} msgId The packet replyTo ID for which the callback was registered.
             *
             * @return {Boolean} True if the cancel was successful, otherwise false.
             */
            cancelRegisteredCallback: function (msgId) {
                var success = false;
                if (msgId) {
                    delete this.registeredCallbacks[msgId];
                    delete this.watchMsgMap[msgId];
                    success = true;
                }
                return success;
            },

            /**
             * Registers callbacks
             *
             * @method on
             * @param {String} event The event to call the callback on.
             * @param {Function} callback The function to be called.
             *
             */
            on: function (event, callback) {
                if (event === &quot;connected&quot; &amp;&amp; this.isConnected()) {
                    callback(this);
                    return;
                }
                return this.events.on.apply(this.events, arguments);
            },

            /**
             * De-registers callbacks
             *
             * @method off
             * @param {String} event The event to call the callback on.
             * @param {Function} callback The function to be called.
             *
             */
            off: function (event, callback) {
                return this.events.off.apply(this.events, arguments);
            },

            /**
             * Handles intent invocation packets. Communicates back with the intents.api to operate the in flight
             * intent
             * state machine.
             *
             * @method intentInvocationHandling
             * @param resource {String} The resource of the packet that sent the intent invocation
             * @param inFlightIntent {Object} The in flight intent, used internally to operate the in flight intent
             *     state machine
             * @param callback {Function} The intent handler&#x27;s callback function
             * @return {Promise}
             */
            intentInvocationHandling: function (packet, inFlightIntent, callback) {
                var self = this;
                var res;
                var promiseChain;
                callback = callback || function () {};
                inFlightIntent = inFlightIntent || {};
                if (inFlightIntent.entity) {
                    promiseChain = Promise.resolve(inFlightIntent);
                } else {
                    promiseChain = self.send({
                        dst: &quot;intents.api&quot;,
                        action: &quot;get&quot;,
                        resource: inFlightIntent.resource
                    });
                }
                return promiseChain.then(function (inFlightIntentRes) {
                    res = inFlightIntentRes;
                    if (res.entity.invokePacket.msgId === packet.msgId) {
                        callback(packet);
                        return Promise.reject(&quot;ownInvoke&quot;);
                    }
                    return self.send({
                        dst: &quot;intents.api&quot;,
                        contentType: res.contentType,
                        action: &quot;set&quot;,
                        resource: res.resource,
                        entity: {
                            handler: {
                                resource: packet.resource,
                                address: self.address
                            },
                            me: Date.now(),
                            state: &quot;running&quot;
                        }
                    });
                }).then(function () {
                    // Run the intent handler. Wrapped in a promise chain in case the callback itself is async.
                    return callback(res.entity, inFlightIntent);
                }).then(function (result) {
                    // Allow the callback to override the intent state (usefull for preventing intent resolution if
                    // chained operations are performed.
                    if (result &amp;&amp; result.intentIncomplete) {
                        return Promise.resolve();
                    }
                    // Respond to the inflight resource
                    return self.send({
                        dst: &quot;intents.api&quot;,
                        contentType: res.contentType,
                        action: &quot;set&quot;,
                        resource: res.resource,
                        entity: {
                            reply: {
                                &#x27;entity&#x27;: result || {},
                                &#x27;contentType&#x27;: res.entity.intent.type
                            },
                            state: &quot;complete&quot;
                        }
                    });
                })[&#x27;catch&#x27;](function (e) {
                    if (e === &quot;ownInvoke&quot;) {
                        //Filter out own invocations (this occurs when watching an invoke state).
                        return;
                    }

                    console.error(&quot;Error in handling intent: &quot;, e, &quot; -- Reporting error on in-flight intent node:&quot;,
                        res.resource);
                    // Respond to the inflight resource
                    return self.send({
                        dst: &quot;intents.api&quot;,
                        contentType: res.contentType,
                        action: &quot;set&quot;,
                        resource: res.resource,
                        entity: {
                            reply: {
                                &#x27;entity&#x27;: e.toString() || {},
                                &#x27;contentType&#x27;: &quot;text/plain&quot;
                            },
                            state: &quot;error&quot;
                        }
                    });
                });
            },

            /**
             * Calls the specific api wrapper given an api name specified.
             * If the wrapper does not exist it is created.
             *
             * @method api
             * @param apiName {String} The name of the api.
             * @return {Function} returns the wrapper call for the given api.
             */
            api: function (apiName) {
                return this.wrapperMap[apiName] || this.updateApi(apiName);
            },
            /**
             * Updates the wrapper map for api use. Whenever functionality is added or removed from the apiMap the
             * updateApi must be called to reflect said changes on the wrapper map.
             *
             * @method updateApi
             * @param apiName {String} The name of the api
             * @return {Function} returns the wrapper call for the given api.
             */
            updateApi: function (apiName) {

                // wrapper is a function because pre 1.2.0 the syntax expected
                // api&#x27;s to be accessed through a function. The function returns
                // itself so to support legacy but properties are on wrapper so
                // functional access is not neccessary. -KJK
                var wrapper = function() {
                    return wrapper;
                };

                this.wrapperMap[apiName] = wrapper;
                if (this.apiMap.hasOwnProperty(apiName)) {
                    var api = this.apiMap[apiName];
                    var apiWrapper = this;

                    /**
                     *  All message formatting calls sits inside the API wrapper&#x27;s messageBuilder object. These
                     *  calls will return a formatted message ready to be sent.
                     *  (e.g: data().messageBuilder.set)
                     */
                    wrapper.messageBuilder = {};
                    wrapper.messageBuilder.bulkSend = function(messages, otherCallback) {
                        var packet = {
                            &#x27;dst&#x27;: api.address,
                            &#x27;action&#x27;: &quot;bulkSend&quot;,
                            &#x27;resource&#x27;: &quot;/&quot;,
                            &#x27;entity&#x27;: messages
                        };

                        return {
                            &#x27;packet&#x27;: packet,
                            &#x27;callback&#x27;: otherCallback
                        };
                    };

                    /**
                     * All function calls are on the root level of the API wrapper. These calls will format messages and
                     * then send them to the router.
                     * (e.g: data().set)
                     */
                    wrapper.bulkSend = (function(bulkMessageBuilder, client) {
                        return function (messages) {
                            var message = bulkMessageBuilder(messages);
                            return client.send(message.packet, message.callback);
                        };
                    })(wrapper.messageBuilder.bulkSend, this);

                    /**
                     * Iterate over all mapped function calls and augment their message formatter and function call.
                     */
                    for (var i = 0; i &lt; api.actions.length; ++i) {
                        var action = api.actions[i];
                        wrapper.messageBuilder[action] = messageBuilderAugment(api.address, action, this);
                        wrapper[action] = augment(wrapper.messageBuilder[action], this);
                    }

                    /**
                     * Creates a reference to the api node, but auto applies the given resource
                     * as well as applies default packet properties.
                     *
                     * @class Reference
                     * @constructor
                     * @param  {String} resource      The resource path to reference
                     * @param  {Object} defaultPacket Default values for the packets sent to the node
                     * @return {Object}               an augmented reference to the api resource.
                     */
                    wrapper.Reference = function(resource, defaultPacket) {

                        this.resource = resource;
                        this.apiWrapper = apiWrapper;
                        this.defaultPacket = {
                            resource: this.resource
                        };
                        this.messageBuilder = {};
                        for (var j in defaultPacket) {
                            this.defaultPacket[j] = defaultPacket[j];
                        }

                        for (var i = 0; i &lt; api.actions.length; ++i) {
                            var action = api.actions[i];
                            this.messageBuilder[action] = messageBuilderRefAugment(api.address, action, this.defaultPacket, this.apiWrapper);
                            this[action] = augment(this.messageBuilder[action], this);
                        }
                    };

                    /**
                     * A modified send for References. Returns only the direct
                     * entity of a response as apposed to the whole packet by
                     * default
                     * @method send
                     * @param  {Object|Function}   fields   packet properties for transmit
                     * @param  {Function} callback          callback function for watched functionality
                     * @return {Promise}    The promise to be resolved
                     */
                    wrapper.Reference.prototype.send = function (fields, callback) {
                        var self = this;
                        var entityPromiseRes, entityPromiseRej;
                        var promise = new Promise(function(res,rej) {
                            entityPromiseRes = res;
                            entityPromiseRej = rej;
                        });
                        var entityCallback = function(response,done) {
                            var value = (self.defaultPacket.fullCallback ) ?
                                    response : response.entity;

                            // If this is an intent invocation, collecting doesn&#x27;t apply
                            // If its an update about an intent invocation trigger change
                            // If not collecting, only trigger on value change
                            if (response.response !== &quot;complete&quot; &amp;&amp; response.response !== &quot;update&quot; &amp;&amp; !response.invokePacket &amp;&amp;
                                !self.defaultPacket.collect) {

                                if (response.entity.newValue !== response.entity.oldValue){
                                    return callback(value, done, response);
                                }
                            } else {
                                return callback(value, done, response);
                            }
                        };

                        this.apiWrapper.send(fields, entityCallback, entityPromiseRes, entityPromiseRej);

                        return promise.then(function(response) {
                            return (self.defaultPacket.fullResponse) ? response : response.entity;
                        }, function(err) {
                            throw (self.defaultPacket.fullResponse) ? err : err.response;
                        });
                    };

                    /**
                     * Updates the default parameters of a Reference. Can be used
                     * to reassign defaults of a Reference
                     * @method updateDefaults
                     * @param  {Object} config configuration properties of Reference to update
                     * @return {Object}        The Reference
                     */
                    wrapper.Reference.prototype.updateDefaults = function(config) {
                        if (typeof config === &quot;object&quot;) {
                            for (var i in config) {
                                this.defaultPacket[i] = config[i];
                            }
                        }
                        return this;
                    };
                }

                wrapper.apiName = apiName;
                return wrapper;
            },

            /**
             * Applies necessary properties to the packet to be transmitted through the router.
             *
             * @method fixPacket
             * @param {Object} fields
             * @return {Object}
             */
            fixPacket: function (fields) {
                var packet = {
                    ver: 1,
                    src: fields.src || this.address,
                    msgId: fields.msgId || &quot;p:&quot; + this.msgIdSequence++,
                    time: fields.time || new Date().getTime()
                };

                for (var k in fields) {
                    packet[k] = util.ifUndef(fields[k], packet[k]);
                }

                if (packet.src === &quot;$nobody&quot;) {
                    packet.src = this.address;
                }

                return packet;
            },

            /**
             * Registers callbacks for API request callbacks and promises.
             *
             * @method registerResponses
             * @property {Object} packet
             * @property {Function} callback
             * @property {Function} promiseRes
             * @property {Function} promiseRej
             */
            registerResponses: function (packet, callback, promiseRes, promiseRej) {
                var self = this;
                if (callback) {
                    this.registeredCallbacks[packet.msgId] = function (reply, done) {

                        // We&#x27;ve received a message that was a promise response but we&#x27;ve aready handled our promise
                        // response.
                        if (/(ok).*/.test(reply.response) || /(bad|no).*/.test(reply.response)) {

                            // Do nothing and let it get sent to the event handler (this is to filter out registration
                            // of callback responses)
                            return false;
                        } else if (reply.entity &amp;&amp; reply.entity.inFlightIntent) {
                            self.intentInvocationHandling(packet, reply.entity.inFlightIntent, callback);
                        } else {

                            // reply passed twice to adhere to
                            // References internal callback signature.
                            callback(reply, done, reply);
                        }
                        return true;
                    };
                }

                //respondOn &quot;all&quot;, &quot;error&quot;, or no value (default all) will register a promise callback.
                if (packet.respondOn !== &quot;none&quot;) {
                    this.promiseCallbacks[packet.msgId] = function (reply, done) {
                        if (reply.src === &quot;intents.api&quot; &amp;&amp;
                            (packet.action === &quot;invoke&quot; &amp;&amp; /(ok).*/.test(reply.response)) ||
                            (packet.action === &quot;broadcast&quot; &amp;&amp; /(complete).*/.test(reply.response))) {
                            // dont sent the response to the promise
                        } else if (reply.src === &quot;intents.api&quot; &amp;&amp; packet.action === &quot;broadcast&quot; &amp;&amp; /(pending).*/.test(reply.response)) {
                            //Broadcast request acknowledged and prepares logic ot handle resolving once all runners
                            // finish.
                            if (self.registeredCallbacks[packet.msgId]) {
                                self.registeredCallbacks[packet.msgId].handlers = reply.entity.handlers || [];
                                self.registeredCallbacks[packet.msgId].pRes = promiseRes;
                                self.registeredCallbacks[packet.msgId].reply = reply;
                            }
                            done();
                        } else if (reply.src === &quot;$transport&quot; || /(ok).*/.test(reply.response) || /(complete).*/.test(reply.response)) {
                            done();
                            promiseRes(reply);
                        } else if (/(bad|no).*/.test(reply.response)) {
                            done();
                            promiseRej(reply);
                        } else {
                            // it was not a promise callback
                        }
                    };
                }

                if (packet.action === &quot;watch&quot;) {
                    this.watchMsgMap[packet.msgId] = packet;
                } else if (packet.action === &quot;unwatch&quot; &amp;&amp; packet.replyTo) {
                    this.cancelRegisteredCallback(packet.replyTo);
                }

                if (packet.action === &quot;bulkSend&quot;) {
                    packet.entity.forEach(function (message) {
                        self.registerResponses(message.packet, message.callback, message.res, message.rej);
                    });
                }
            },
            /**
             * Sends a packet through the IWC.
             * Will call the participants sendImpl function.
             *
             * @method send
             * @param {Object} fields properties of the send packet..
             * @param {Function} callback The Callback for any replies. The callback will be persisted if it returns a
             *     truth-like
             * @param {Function} preexistingPromiseRes If this send already has a promise resolve registration, use it
             *     rather than make a new one.
             * @param {Function} preexistingPromiseRej If this send already has a promise reject registration, use it
             *     rather than make a new one. value, canceled if it returns a false-like value.
             */
            send: function (fields, callback, preexistingPromiseRes, preexistingPromiseRej) {
                if (this.sendingBlocked) {
                    return Promise.resolve({response: &quot;dropped&quot;});
                }
                var promiseRes = preexistingPromiseRes;
                var promiseRej = preexistingPromiseRej;
                var promise = new Promise(function (resolve, reject) {

                    if (!promiseRes &amp;&amp; !promiseRej) {
                        promiseRes = resolve;
                        promiseRej = reject;
                    }
                });

                if (!(this.isConnected() || fields.dst === &quot;$transport&quot;)) {
                    // when send is switched to promises, create the promise first and return it here, as well
                    this.preconnectionQueue.push({
                        &#x27;fields&#x27;: fields,
                        &#x27;callback&#x27;: callback,
                        &#x27;promiseRes&#x27;: promiseRes,
                        &#x27;promiseRej&#x27;: promiseRej
                    });
                    return promise;
                }
                var packet = this.fixPacket(fields);
                this.registerResponses(packet, callback, promiseRes, promiseRej);
                fixBulkSend(packet);
                this.sendImpl(packet);
                this.sentBytes += packet.length;
                this.sentPackets++;

                return promise;
            },

            /**
             * Generic handler for a bus connection to handle any queued messages &amp; launch data after its connected.
             * @method afterConnected
             * @return {Promise}
             */
            afterConnected: function () {
                var self = this;
                // dump any queued sends, trigger that we are fully connected
                self.preconnectionQueue.forEach(function (p) {
                    self.send(p.fields, p.callback, p.promiseRes, p.promiseRej);
                });
                self.preconnectionQueue = [];
                if (!self.launchParams.inFlightIntent || self.internal) {
                    self.events.trigger(&quot;connected&quot;);
                    return Promise.resolve();
                }

                // fetch the inFlightIntent
                return self.intents().get(self.launchParams.inFlightIntent).then(function (response) {
                    // If there is an inflight intent that has not already been handled (i.e. page refresh driving to
                    // here)
                    if (response &amp;&amp; response.entity &amp;&amp; response.entity.intent) {
                        var launchParams = response.entity.entity || {};
                        if (response.response === &#x27;ok&#x27;) {
                            for (var k in launchParams) {
                                self.launchParams[k] = launchParams[k];
                            }
                        }
                        self.intents().set(self.launchParams.inFlightIntent, {
                            entity: {
                                state: &quot;complete&quot;
                            }
                        });

                        if (self.launchParams.launchData &amp;&amp; self.launchParams.launchData.inFlightIntent) {
                            self.launchedIntents.push(self.launchParams.launchData.inFlightIntent);
                        }
                    }
                    self.events.trigger(&quot;connected&quot;);
                })[&#x27;catch&#x27;](function (e) {
                    console.error(self.launchParams.inFlightIntent, &quot; not handled, reason: &quot;, e);
                    self.events.trigger(&quot;connected&quot;);
                });
            }

        };
    };
//---------------------------------------------------------
// Private Methods
//---------------------------------------------------------
    /**
     * Augmentation for Intents Api register. Automatically invokes a registration if the invoke was passed
     * into the application opening.
     * @method intentRegisterAugment
     * @private
     * @static
     * @param client
     * @param message
     */
    var intentRegisterAugment = function (client, message) {
        for (var i in client.launchedIntents) {
            var loadedResource = &#x27;/&#x27; + client.launchedIntents[i].entity.intent.type + &#x27;/&#x27; + client.launchedIntents[i].entity.intent.action;
            if (message.packet.resource === loadedResource) {
                client.intentInvocationHandling(message.packet, client.launchedIntents[i], message.callback);
                delete client.launchedIntents[i];
            }
        }
    };


    /**
     * Augmentation for Intents Api invoke. Wraps callback to remove the callback when reaching
     * error/complete state.
     * @method intentRegisterAugment
     * @private
     * @static
     * @param client
     * @param message
     */
    var intentInvokeAugment = function (message) {
        if (message.callback) {
            var wrappedCallback = message.callback;
            // Wrap the callback to make sure it is removed when the intent state machine stops.
            message.callback = function (reply, done) {
                wrappedCallback(reply, done);
                reply = reply || {};
                reply.entity = reply.entity || {};
                if (reply.entity.state === &quot;error&quot; || reply.entity.state === &quot;complete&quot;) {
                    done();
                }
            };
        }
    };

    /**
     * Augmentation for Intents Api broadcast. Compiles the results of all intent handlers and then,
     * returns the responfixese in the promise resolution. Callback acts like invoke callback.
     * @method intentRegisterAugment
     * @private
     * @static
     * @param client
     * @param message
     */
    var intentBroadcastAugment = function (client, message) {
        var broadcastWrappedCallback = message.callback || function () {};
        var registeredCallbacks = client.registeredCallbacks;

        // Wrap the callback to filter out all of the &quot;complete&quot; messages from each handler sent
        // intended for a promise resolution. Also store all results for the promise resolution.
        message.callback = function (reply, done, fullReply) {
            if (!registeredCallbacks[fullReply.replyTo]) {
                return;
            }
            var callback = registeredCallbacks[fullReply.replyTo];
            var handlers = callback.handlers;
            var attemptResolve = function (resource) {
                var handlerIndex = handlers.indexOf(resource);
                if (handlerIndex &gt; -1) {
                    handlers.splice(handlerIndex, 1);
                }
                if (handlers.length === 0) {
                    callback.reply.entity = callback.results;
                    callback.reply.response = &quot;complete&quot;;
                    callback.pRes(callback.reply);
                    done();
                }
            };
            if (fullReply.response === &quot;complete&quot;) {
                callback.results = callback.results || {};
                callback.results[fullReply.resource] = fullReply.entity;
                attemptResolve(fullReply.resource);

            } else if (fullReply.entity &amp;&amp; fullReply.entity.state === &quot;error&quot; &amp;&amp; client.registeredCallbacks[fullReply.replyTo]) {
                attemptResolve(fullReply.entity.handler.resource);
            } else {
                broadcastWrappedCallback(fullReply, done);
            }
        };
    };

    /**
     * Augmenters for Intent Api specific actions.
     * @method intentAugment
     * @private
     * @static
     * @param client
     * @param message {Object}
     */
    var intentAugment = function (client, message) {
        var clientRef = client.apiWrapper || client;
        switch (message.packet.action) {
            case &quot;register&quot;:
                intentRegisterAugment(clientRef, message);
                break;
            case &quot;invoke&quot;:
                intentInvokeAugment(message);
                break;
            case &quot;broadcast&quot;:
                intentBroadcastAugment(clientRef, message);
                break;

        }
    };

    /**
     * Function generator. Generates API functions given a messageBuilder function.
     * @method augment
     * @private
     * @static
     * @param messageBuilder
     * @param client
     * @return {Function}
     */
    var augment = function (messageBuilder, client) {
        return function() {
            // Augmentation clarification: If using 1.2.0 references, messageBuilder
            // is generated in messageBuilderRefAugment and expects 2 parameters
            // (1) entity, (2) callback. Follows original messageBuilder in
            // handling callback as first parameter. -KJK
            var message = messageBuilder.apply(this,arguments);


            if (message.packet.dst === &quot;intents.api&quot;) {
                intentAugment(client, message);
            }
            return client.send(message.packet, message.callback);
        };
    };



    /**
     * Function generator. Generates API message formatting functions for a client-destination-action
     * pairing. These are generated for bulk sending capabilities, since the message needs to be formatted
     * but not transmitted until desired.
     *
     * @method messageBuilderAugment
     * @private
     * @static
     * @param dst
     * @param action
     * @param client
     * @return {Function}
     */
    var messageBuilderAugment = function (dst, action, client) {
        return function (param1, param2, param3) {
            var callback = param3;
            var fragment = param2;

            if (typeof param2 === &quot;function&quot;) {
                callback = param2;
                fragment = {};
            }

            var packet = {
                &#x27;dst&#x27;: dst,
                &#x27;action&#x27;: action,
                &#x27;resource&#x27;: param1,
                &#x27;entity&#x27;: {}
            };

            for (var k in fragment) {
                packet[k] = fragment[k];
            }

            var resolve, reject;
            var sendData = new Promise(function (res, rej) {
                resolve = res;
                reject = rej;
            });

            sendData.packet = client.fixPacket(packet);
            sendData.callback = callback;
            sendData.res = resolve;
            sendData.rej = reject;
            return sendData;
        };
    };

    /**
     * A factory for generating messages for a given API &amp; Action.
     * @method messageBuilderRefAugment
     * @private
     * @static
     * @param  {String} dst           [description]
     * @param  {String} action        [description]
     * @param  {Object} defaultPacket [description]
     * @param  {Object} client        [description]
     * @return {Function}             Returns a funciton that when called returns formatted packet,callback, and promise resolution calls.
     */
    var messageBuilderRefAugment = function (dst, action, defaultPacket, client) {
        return function(param1, param2) {
            var body = param1;
            var callback = param2;

            // If a fragment isn&#x27;t supplied argument #2 should be a callback (if supplied)
            if (typeof param1 === &quot;function&quot;) {
                callback = param1;
                body = undefined;
            }

            var packet = defaultPacket;
            packet.dst = dst;
            packet.action = action;
            packet.entity = body;

            var resolve, reject;
            var sendData = new Promise(function (res, rej) {
                resolve = res;
                reject = rej;
            });

            sendData.packet = client.fixPacket(packet);
            sendData.callback = callback;
            sendData.res = resolve;
            sendData.rej = reject;
            return sendData;
        };
    };

    /**
     * Handles packets received with a destination of &quot;$bus.multicast&quot;.
     * If the packet action isn&#x27;t handled, the function will return falsy.
     *
     * @method handleBusPacket
     * @private
     * @static
     * @param {ozpIwc.api.base.Api} apiBase
     * @param {Object} packetContext
     * @return {*}
     */
    var handleBusPacket = function (mixer, packet) {
        switch (packet.action) {
            case &quot;connect&quot;:
                mixer.events.trigger(&quot;addressConnects&quot;, packet.entity.address, packet);
                return true;
            case &quot;disconnect&quot;:
                mixer.events.trigger(&quot;addressDisconnects&quot;, packet.entity.address, packet);
                return true;
        }
    };


    /**
     * A fix for bulkSend functionality, Filters out promise functionality
     * so structured clones apply to bulkSends.
     * @method fixBulkSend
     * @private
     * @static     *
     * @param  {Object} packet
     * @return {Object}        a reference to the packet.
     */
    var fixBulkSend = function(packet) {
        if (packet.action === &quot;bulkSend&quot;) {
            packet.entity = packet.entity.map(function(message) {
                return {
                    packet: message.packet
                };
            });
        }
        return packet;
    };

    return ApiPromiseMixin;
}(ozpIwc.apiMap, ozpIwc.log, ozpIwc.util));

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
